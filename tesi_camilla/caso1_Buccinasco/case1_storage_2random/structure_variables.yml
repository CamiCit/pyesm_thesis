# variables of the model

# table_key:                                  # name of the data table from which variables are defined
#     name: table_name                        # description or full name of the table
#     type: table_type                        # endogenous, exogenous, constant or dictionary 
#     type:                                   # dictionary with keys as problem key and values as table_type 
#         problem_key: table_type
#     coordinates: [a, b, c, d]               # list of table coordinates (set_key symbols)
#     variables_info:                         # list of variables defined from the data_table
#         var_key_1:                          # variable name
#             value: constant_type            # constant value type (predefined)
#             rows:                           # (optional) rows of the variable
#                 set: a                      # set_key symbol
#                 filters: {0: filter_values} # (optional) filters for the set values
#             cols:                           # (optional) cols of the variable
#                 set: b                      # set_key symbol
#                 filters: {0: filter_values} # (optional) filters for the set values
#             intra:                          # (optional) filter on intra-problem sets 
#                 set: c                      # set_key symbol
#                 filters: {0: filter_values} # (optional) filters for the set values


# -----------------------------------------------------------------------------
# exogenous variables

u:
  name: u
  type: exogenous
  coordinates: [needs, activities]
  variables_info:
    u:
      needs:
        dim: rows
      activities:
        dim: cols
d:
  name: d   #change of shape from the previous model
  type: exogenous
  coordinates: [needs, activities]
  variables_info:
    d:
      needs:
        dim: rows
      activities:
        dim: cols
cf:
  name: cf
  type: exogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    cf:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: n}

Y:
  name: Y
  type: exogenous
  coordinates: [scenarios, needs, time_hour]
  variables_info:
    Y:
      needs:
        dim: rows
      time_hour:
        dim: cols
cost_op:
  name: cost_op
  type: exogenous
  coordinates: [activities]
  variables_info:
    cost_op:
      activities:
        dim: cols
cost_period:
  name: cost per period (1 year)
  type: exogenous
  coordinates: [techs]
  variables_info:
    cost_period:
      techs:
        dim: cols
cost_cap:
  name: cost per 1 unit of capacity
  type: exogenous
  coordinates: [techs]
  variables_info:
    cost_cap:
      techs:
        dim: cols
cost_inv:
  name: cost_inv
  type: exogenous
  coordinates: [techs]
  variables_info:
    cost_inv:
      techs:
        dim: cols
max_opex:
  name: maximum O&M expenses per year
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    max_opex:

max_capex:
  name: maximum investment expense
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    max_capex:

cap_i:
  name: cap_i
  type: exogenous
  coordinates: [techs]
  variables_info:
    cap_i:
      techs:
        dim: cols
cap_units:
  name: cap_units
  type: exogenous
  coordinates: [techs]
  variables_info:
    cap_units:
      techs:
        dim: cols
Act_constr:
  name: Act_constr
  type: exogenous
  coordinates: [techs, activities]
  variables_info:
    Act_constr:
      activities:
        dim: rows
      techs:
        dim: cols
days_per_type:
  name: Days of each type in one year   #The sum must be 365
  type: exogenous
  coordinates: [scenarios, days]
  variables_info:
    days_per_type:
      days:
        dim: cols
sf:
  name: seasonal activity limit [0,1]
  type: exogenous
  coordinates: [activities, time_hour]
  variables_info:
    sf:
      time_hour:
        dim: rows
      activities:
        dim: cols
        filters: {seasonal: y}

#Thermal insulation
TI_param:        #0 for all needs except cold (value between [0,1]) and heat (value between [-1,0])
  name: TI_param
  type: exogenous
  coordinates: [needs]
  variables_info:
    TI_param:
      needs:
        dim: rows
TI_cost:        #0 for all needs except cold (value between [0,1]) and heat (value between [-1,0])
  name: capital investment cost for thermal insulation
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    TI_cost:

#STORAGE exogenous variables
storage_min:        #valore minimo del livelo di storage [0,1]
  name: storage_min
  type: exogenous
  coordinates: [techs]
  variables_info:
    storage_min:
      techs:
        dim: rows
        filters: {storage: y}

storage_max:        #valore massimo del livelo di storage [0,1]
  name: storage_max
  type: exogenous
  coordinates: [techs]
  variables_info:
    storage_max:
      techs:
        dim: rows
        filters: {storage: y}

storage_start:        #valore iniziale del livelo di storage [0,1], anche se definito per tutti i tempi, vale solo per la prima ora
  name: storage_start
  type: exogenous
  coordinates: [techs]
  variables_info:
    storage_start:
      techs:
        dim: rows
        filters: {storage: y}

storage_max_disch:        #da moltiplicare a capacità di storage [kWh] per ottenere la potenza di scarica massima [kW]
  name: storage_max_disch
  type: exogenous
  coordinates: [techs, time_hour]
  variables_info:
    storage_max_disch:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}

storage_min_charge:        #da moltiplicare a capacità di storage [kWh] per ottenere la potenza di scarica minima [kW], negativo
  name: storage_min_charge
  type: exogenous
  coordinates: [techs, time_hour]
  variables_info:
    storage_min_charge:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}


#BEV exogenous variables
BEV_level_min:        #to be multiplied by BEV sorage capacity [kWh] to obtain min BEV SOC 
  name: BEV_level_min
  type: exogenous
  coordinates: [techs]
  variables_info:
    BEV_level_min:
      techs:
        dim: rows
        filters: {BEV: y}

BEV_level_max:        #to be multiplied by BEV sorage capacity [kWh] to obtain max BEVSOC 
  name: BEV_level_max
  type: exogenous
  coordinates: [techs]
  variables_info:
    BEV_level_max:
      techs:
        dim: rows
        filters: {BEV: y}

BEV_level_start:        #to be multiplied by BEV sorage capacity [kWh] to obtain starting point of BEV SOC 
  name: BEV_level_start
  type: exogenous
  coordinates: [techs]
  variables_info:
    BEV_level_start:
      techs:
        dim: rows
        filters: {BEV: y}

BEV_vector:
  name: BEV_vector
  type: exogenous
  coordinates: [techs, activities]
  variables_info:
    BEV_vector:
      activities:
        dim: rows
      techs:
        dim: cols
        filters: {BEV: y}

loss_factors:
  name: loss(cooling) factor for each storage technology
  type: exogenous
  coordinates: [scenarios, techs]
  variables_info:
    loss_factors:
      techs:
        dim: rows
    loss_factors_t:
      techs:
        dim: intra
        filters: {storage: y}
    loss_factors_BEV:
      techs:
        dim: intra
        filters: {BEV: y}

n_hours:                        #scalar to give as input to T_hh_cool
  name: number of hours
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    n_hours:

n_years:                        #scalar to give as input to power_vector for NPC
  name: number of years
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    n_years:

disc_frac:                        #Scalar: 1/(1+r)
  name: Discount rate fraction
  type: exogenous
  coordinates: [scenarios]
  variables_info:
    disc_frac:
# -----------------------------------------------------------------------------
# endogenous variables
Q:
  name: Q
  type: endogenous
  coordinates: [scenarios, time_hour, needs]
  variables_info:
    Q:
      time_hour:
        dim: rows
      needs:
        dim: cols
X:
  name: X
  type: endogenous
  coordinates: [scenarios, time_hour, activities]
  variables_info:
    X:
      time_hour:
        dim: rows
      activities:
        dim: cols
    X_storage:
      time_hour:
        dim: rows
      activities:
        dim: cols
        filters: {storage: y}
    X_no_stor:
      time_hour:
        dim: rows
      activities:
        dim: cols
        filters: {storage: n}
    X_season:
      time_hour:
        dim: rows
      activities:
        dim: cols
        filters: {seasonal: y}
    X_no_peak:
      time_hour:
        dim: rows
        filters: {peak: n}
      activities:
        dim: cols
    X_stor_peak:
      time_hour:
        dim: rows
        filters: {peak: y}
      activities:
        dim: cols
        filters: {storage: y}

curtail:
  name: curtail
  type: endogenous
  coordinates: [scenarios, time_hour, needs]
  variables_info:
    curtail:
      needs:
        dim: rows
      time_hour:
        dim: cols
    curtail_peak:
      needs:
        dim: rows
      time_hour:
        dim: cols
        filters: {peak: y}

new_units:
  name: new_units   #integer variable
  type: endogenous_integer
  coordinates: [scenarios, techs]
  variables_info:
    new_units:
      techs:
        dim: cols
cap_new:
  name: cap_new
  type: endogenous_integer
  coordinates: [scenarios, techs]
  variables_info:
    cap_new:
      techs:
        dim: cols
    cap_new_BEV:
      techs:
        dim: cols
        filters: {BEV: y}

active_techs:
  name: active technologies   #binary variable
  type: endogenous_integer
  coordinates: [scenarios, techs]
  variables_info:
    active_techs:
      techs:
        dim: cols
cost_op_hours:
  name: cost_op_hours
  type: endogenous
  coordinates: [scenarios, time_hour, activities]
  variables_info:
    cost_op_hours:
      time_hour:
        dim: rows
      activities:
        dim: cols
cost_op_tot:
  name: cost_op_tot
  type: endogenous
  coordinates: [scenarios, activities]
  variables_info:
    cost_op_tot:
      activities:
        dim: cols
cost_op_year:
  name: cost_op_year
  type: endogenous
  coordinates: [scenarios]
  variables_info:
    cost_op_year:

cost_inv_tot:
  name: cost_inv_tot
  type: endogenous
  coordinates: [scenarios]
  variables_info:
    cost_inv_tot:

X_t:
  name: X_agg_techs
  type: endogenous
  coordinates: [scenarios, time_hour, techs]
  variables_info:
    X_t:
      time_hour:
        dim: rows
      techs:
        dim: cols
    X_t_no_stor:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: n}
    X_t_stor:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}
    X_t_stor_t:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: intra
        filters: {storage: y}
    X_t_stor_all:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}

X_max:
  name: X_max
  type: endogenous
  coordinates: [scenarios, time_hour, techs]
  variables_info:
    X_max:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: n}

cap_tot:
  name: cap_tot
  type: endogenous
  coordinates: [scenarios, techs]
  variables_info:
    cap_tot:
      techs:
        dim: cols
    cap_tot_no_stor:
      techs:
        dim: cols
        filters: {storage: n}
    cap_tot_stor:
      techs:
        dim: cols
        filters: {storage: y}
    cap_tot_BEV:
      techs:
        dim: cols
        filters: {BEV: y}

#Thermal insulation
insulation:
  name: thermal insulation      #Should be binary: 1 if is installed, 0 if isnt
  type: endogenous
  coordinates: [scenarios]
  variables_info:
    insulation:

TI:        #0 for all needs except cold (value between [0,1]) and heat (value between [-1,0])
  name: Thermal Insulation effect
  type: endogenous
  coordinates: [scenarios, needs]
  variables_info:
    TI:
      needs:
        dim: rows
act_capacity:
  name: total capacity per activity
  type: endogenous
  coordinates: [scenarios, activities]
  variables_info:
    act_capacity:
      activities:
        dim: cols
    season_capacity:
      activities:
        dim: cols
        filters: {seasonal: y}

season_limit:
  name: seasonal activity limit
  type: endogenous
  coordinates: [scenarios, activities, time_hour]
  variables_info:
    season_limit:
      time_hour:
        dim: rows
      activities:
        dim: cols
        filters: {seasonal: y}

#STORAGE
SOC_min:        #valore minimo del livelo di storage [kWh]
  name: SOC_min
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    SOC_min:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {storage: y}

SOC_max:        #valore massimo del livelo di storage [kWh]
  name: SOC_max
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    SOC_max:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {storage: y}

SOC_start:        #valore iniziale del livelo di storage [kWh], anche se definito per tutti i tempi, vale solo per la prima ora
  name: SOC_start
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    SOC_start:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {storage: y}
    SOC_start_t:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: intra
        filters: {storage: y}

SOC:
  name: SOC
  type: endogenous
  coordinates: [scenarios, time_hour, techs]
  variables_info:
    SOC:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {storage: y}
    SOC_t:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: intra
        filters: {storage: y}


max_disch:        #valore massimo per X dello storage= massima scarica [kW]
  name: max_disch
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    max_disch:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}

min_charge:        #valore minimo (negativo) per X dello storage= massimo valore assoluto di carica [kW]
  name: min_charge
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    min_charge:
      time_hour:
        dim: rows
      techs:
        dim: cols
        filters: {storage: y}

# SOC_start_cool: #controllo per la prima parte di SOC
#     name: SOC_start_cool
#     type: endogenous
#     coordinates: [scenarios,techs,time_hour]
#     variables_info:
#         SOC_start_cool:
#             rows:
#                 set: time_hour
#             cols:
#                 set: techs
#                 filters: {storage: y}

# SOC_second_part: #controllo per la seconda parte di SOC
#     name: SOC_second_part
#     type: endogenous
#     coordinates: [scenarios,activities,time_hour]
#     variables_info:
#         SOC_second_part:
#             rows:
#                 set: time_hour
#             cols:
#                 set: activities
#                 filters: {storage: y}


#BEV endogenous variables
BEV_SOC_min:
  name: BEV_SOC_min
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    BEV_SOC_min:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {BEV: y}

BEV_SOC_max:
  name: BEV_SOC_max
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    BEV_SOC_max:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {BEV: y}

BEV_SOC_start:
  name: BEV_SOC_start
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    BEV_SOC_start:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {BEV: y}

# intermedio_BEV:
#     name: intermedio_BEV
#     type: endogenous
#     coordinates: [scenarios,techs,time_hour]
#     variables_info:
#         intermedio_BEV:
#             rows:
#                 set: time_hour
#                 filters: {peak: n}
#             cols:
#                 set: techs
#                 filters: {BEV: y}

BEV_SOC:
  name: BEV_SOC
  type: endogenous
  coordinates: [scenarios, techs, time_hour]
  variables_info:
    BEV_SOC:
      time_hour:
        dim: rows
        filters: {peak: n}
      techs:
        dim: cols
        filters: {BEV: y}

# -----------------------------------------------------------------------------
# constants variables

I_ta:
  name: special identity matrix for activities aggregation into technologies
  type: constant
  coordinates: [techs, activities]
  variables_info:
    I_ta:
      value: identity_rcot
      techs:
        dim: rows
      activities:
        dim: cols
N_ones:
  name: Vector of 1s as long as needs
  type: constant
  coordinates: [needs]
  variables_info:
    N_ones:
      value: sum_vector
      needs:
        dim: cols
H_ones:
  name: Column vector of 1s as long as hours (peak excluded)
  type: constant
  coordinates: [time_hour]
  variables_info:
    H_ones:
      value: sum_vector
      time_hour:
        dim: rows
        filters: {peak: n}

H_ones_row:
  name: Row vector of 1s as long as hours (peak included)
  type: constant
  coordinates: [time_hour]
  variables_info:
    H_ones_row:
      value: sum_vector
      time_hour:
        dim: cols
A_ones:
  name: Column vector of 1s as long as hours (peak excluded)
  type: constant
  coordinates: [activities]
  variables_info:
    A_ones:
      value: sum_vector
      activities:
        dim: rows
I_dh:
  name: special identity matrix for hours aggregation into days
  type: constant
  coordinates: [days, time_hour]
  variables_info:
    I_dh:
      value: identity_rcot
      days:
        dim: rows
      time_hour:
        dim: cols
